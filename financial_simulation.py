# -*- coding: utf-8 -*-
"""Financial Simulation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y-I8CwEUnnv3fQz8tBwTi1kV850Yvmiv

# Imports
"""

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import pandas as pd
from scipy.optimize import newton

"""# Functions

## Summary Statistics
"""

def calculate_irr(cash_flows, times):
    """
    Calculate Internal Rate of Return (IRR) given cash flows and their timing.

    Parameters:
    -----------
    cash_flows : list
        List of cash flows (negative for contributions, positive for final value)
    times : list
        List of times in years when each cash flow occurred

    Returns:
    --------
    float : IRR as a decimal (e.g., 0.05 for 5%)
    """
    def npv(rate):
        return sum(cf / (1 + rate) ** t for cf, t in zip(cash_flows, times))

    def npv_derivative(rate):
        return sum(-t * cf / (1 + rate) ** (t + 1) for cf, t in zip(cash_flows, times))

    try:
        # Use Newton's method to find the rate where NPV = 0
        irr = newton(npv, 0.05, fprime=npv_derivative, maxiter=100)
        return irr
    except:
        # If Newton's method fails, return NaN
        return np.nan

def extract_simulation_data(simulation_results):
    """
    Extract key data arrays from simulation results.

    Parameters:
    -----------
    simulation_results : dict
        Dictionary containing simulation results

    Returns:
    --------
    dict : Contains arrays of final_values, baselines, all_timeseries, sequence_indices
    """
    final_values = []
    all_timeseries = []
    baselines = []
    sequence_indices = []

    for i, result_dict in enumerate(simulation_results['result_dict']):
        # Calculate total value (excluding baseline)
        final_total = (result_dict['SP500'][-1] +
                       result_dict['NASDAQ100'][-1] +
                       result_dict['TBILL_3M'][-1] +
                       result_dict['HYSA'][-1] +
                       result_dict['Emergency_fund'][-1])
        final_values.append(final_total)
        baselines.append(result_dict['Baseline'][-1])
        sequence_indices.append(simulation_results['sequence_index'][i])

        # Calculate total value at each month
        timeseries = []
        for j in range(len(result_dict['Month_Index'])):
            total = (result_dict['SP500'][j] +
                     result_dict['NASDAQ100'][j] +
                     result_dict['TBILL_3M'][j] +
                     result_dict['HYSA'][j] +
                     result_dict['Emergency_fund'][j])
            timeseries.append(total)
        all_timeseries.append(timeseries)

    return {
        'final_values': np.array(final_values),
        'baselines': np.array(baselines),
        'all_timeseries': all_timeseries,
        'sequence_indices': np.array(sequence_indices)
    }

def calculate_all_irrs(simulation_results, time_to_new_job, time_to_kid,
                       starting_contribution, next_job_contribution,
                       after_kid_contribution, HYSA_monthly_returns):
    """
    Calculate IRR for all simulations (both portfolio and baseline).

    Parameters:
    -----------
    simulation_results : dict
        Dictionary containing simulation results
    time_to_new_job : int
        Months until new job starts
    time_to_kid : int
        Months until kid arrives
    starting_contribution : float
        Initial monthly contribution
    next_job_contribution : float
        Contribution after new job
    after_kid_contribution : float
        Contribution after kid
    HYSA_monthly_returns : float
        Monthly HYSA return rate

    Returns:
    --------
    dict : Contains arrays of irr_returns and baseline_irr_returns
    """
    irr_returns = []
    baseline_irr_returns = []

    print("\nCalculating IRR for all simulations (this may take a moment)...")

    for idx, result_dict in enumerate(simulation_results['result_dict']):
        if idx % 10000 == 0 and idx > 0:
            print(f"  Processed {idx:,} / {len(simulation_results['result_dict']):,} simulations...")

        # Build cash flow list for portfolio
        cash_flows = []
        times = []

        # Initial investment (negative = outflow)
        initial = (result_dict['SP500'][0] +
                  result_dict['NASDAQ100'][0] +
                  result_dict['TBILL_3M'][0] +
                  result_dict['HYSA'][0] +
                  result_dict['Emergency_fund'][0])
        cash_flows.append(-initial)
        times.append(0)

        # Monthly contributions
        total_months = len(result_dict['Month_Index']) - 1
        for month_idx in range(1, total_months + 1):
            month = month_idx - 1
            if month < time_to_new_job:
                contribution = starting_contribution
            elif month < time_to_kid:
                contribution = next_job_contribution
            else:
                contribution = after_kid_contribution

            cash_flows.append(-contribution)
            times.append(month_idx / 12)

        # Final value (positive = inflow)
        final = (result_dict['SP500'][-1] +
                result_dict['NASDAQ100'][-1] +
                result_dict['TBILL_3M'][-1] +
                result_dict['HYSA'][-1] +
                result_dict['Emergency_fund'][-1])
        cash_flows.append(final)
        times.append(15)

        # Calculate IRR
        irr = calculate_irr(cash_flows, times)
        if not np.isnan(irr):
            irr_returns.append(irr * 100)

        # Build cash flow list for baseline
        baseline_cash_flows = []
        baseline_times = []

        baseline_initial = result_dict['Baseline'][0]
        baseline_cash_flows.append(-baseline_initial)
        baseline_times.append(0)

        # Extract baseline contributions
        for month_idx in range(1, total_months + 1):
            prev_baseline = result_dict['Baseline'][month_idx - 1]
            curr_baseline = result_dict['Baseline'][month_idx]
            baseline_contribution = (curr_baseline / (1 + HYSA_monthly_returns)) - prev_baseline
            baseline_cash_flows.append(-baseline_contribution)
            baseline_times.append(month_idx / 12)

        baseline_final = result_dict['Baseline'][-1]
        baseline_cash_flows.append(baseline_final)
        baseline_times.append(15)

        # Calculate baseline IRR
        baseline_irr = calculate_irr(baseline_cash_flows, baseline_times)
        if not np.isnan(baseline_irr):
            baseline_irr_returns.append(baseline_irr * 100)

    return {
        'irr_returns': np.array(irr_returns),
        'baseline_irr_returns': np.array(baseline_irr_returns)
    }

def calculate_milestone_statistics(simulation_results, year):
    """
    Calculate statistics at a specific year milestone.

    Parameters:
    -----------
    simulation_results : dict
        Dictionary containing simulation results
    year : int
        Year milestone to analyze

    Returns:
    --------
    dict : Statistics for this milestone
    """
    month_index = year * 12

    milestone_values = []
    milestone_baselines = []

    for result_dict in simulation_results['result_dict']:
        if len(result_dict['Month_Index']) > month_index:
            total = (result_dict['SP500'][month_index] +
                    result_dict['NASDAQ100'][month_index] +
                    result_dict['TBILL_3M'][month_index] +
                    result_dict['HYSA'][month_index] +
                    result_dict['Emergency_fund'][month_index])
            milestone_values.append(total)
            milestone_baselines.append(result_dict['Baseline'][month_index])

    milestone_values = np.array(milestone_values)
    milestone_baselines = np.array(milestone_baselines)

    return {
        'p25': np.percentile(milestone_values, 25),
        'p50': np.percentile(milestone_values, 50),
        'p75': np.percentile(milestone_values, 75),
        'avg_baseline': np.mean(milestone_baselines),
        'beat_baseline_pct': np.sum(milestone_values > milestone_baselines) / len(milestone_values) * 100,
        'median_gain': np.percentile(milestone_values, 50) - np.mean(milestone_baselines)
    }

def calculate_sequence_variances(final_values, sequence_indices, complete_sequences):
    """
    Calculate variance for each sequence and return sorted list.

    Parameters:
    -----------
    final_values : array
        Array of final portfolio values
    sequence_indices : array
        Array of sequence indices
    complete_sequences : list
        List of complete sequence dictionaries

    Returns:
    --------
    list : Sorted list of (seq_idx, start_year, end_year, variance) tuples
    """
    sequence_variances = []
    for seq_idx in range(len(complete_sequences)):
        seq_results = final_values[sequence_indices == seq_idx]
        if len(seq_results) > 0:
            variance = np.std(seq_results)
            sequence_variances.append((seq_idx,
                                       complete_sequences[seq_idx]['start_year'],
                                       complete_sequences[seq_idx]['end_year'],
                                       variance))

    return sorted(sequence_variances, key=lambda x: x[3], reverse=True)

def print_summary_statistics(simulation_results, data, irr_data, complete_sequences,
                            total_iterations, time_to_new_job, time_to_kid,
                            starting_contribution, next_job_contribution, after_kid_contribution):
    """
    Print comprehensive summary statistics.

    Parameters:
    -----------
    simulation_results : dict
        Dictionary containing simulation results
    data : dict
        Extracted data (final_values, baselines, etc.)
    irr_data : dict
        IRR calculation results
    complete_sequences : list
        List of complete sequence dictionaries
    total_iterations : int
        Number of iterations per sequence
    time_to_new_job : int
        Months until new job
    time_to_kid : int
        Months until kid
    starting_contribution : float
        Initial contribution amount
    next_job_contribution : float
        New job contribution amount
    after_kid_contribution : float
        After kid contribution amount
    """
    final_values = data['final_values']
    baselines = data['baselines']
    sequence_indices = data['sequence_indices']
    irr_returns = irr_data['irr_returns']
    baseline_irr_returns = irr_data['baseline_irr_returns']

    # Calculate beat baseline percentage
    beat_baseline = np.sum(final_values > baselines) / len(final_values) * 100

    print("\n" + "="*70)
    print("SUMMARY STATISTICS")
    print("="*70)
    print(f"Total simulations: {len(final_values):,}")
    print(f"Number of sequences: {len(complete_sequences)}")
    print(f"Iterations per sequence: {total_iterations:,}")

    # ==================== FINAL (15 YEAR) STATISTICS ====================
    print(f"\n{'='*70}")
    print("FINAL PORTFOLIO VALUE (15 Years):")
    print(f"{'='*70}")
    print(f"  Mean:            ${np.mean(final_values):,.2f}")
    print(f"  Median:          ${np.median(final_values):,.2f}")
    print(f"  Std Dev:         ${np.std(final_values):,.2f}")
    print(f"  Min:             ${np.min(final_values):,.2f}")
    print(f"  Max:             ${np.max(final_values):,.2f}")
    print(f"  10th percentile: ${np.percentile(final_values, 10):,.2f}")
    print(f"  25th percentile: ${np.percentile(final_values, 25):,.2f}")
    print(f"  75th percentile: ${np.percentile(final_values, 75):,.2f}")
    print(f"  90th percentile: ${np.percentile(final_values, 90):,.2f}")
    print(f"\nBaseline (HYSA only):")
    print(f"  Final Value: ${np.mean(baselines):,.2f}")
    print(f"\nOutperformance:")
    print(f"  {beat_baseline:.2f}% of simulations beat the baseline")
    print(f"  Average gain over baseline: ${np.mean(final_values - baselines):,.2f}")
    print(f"  Median gain over baseline:  ${np.median(final_values - baselines):,.2f}")

    # ==================== ANNUALIZED RETURNS (IRR) ====================
    print(f"\n{'='*70}")
    print("ANNUALIZED RETURNS (Internal Rate of Return)")
    print(f"{'='*70}")
    print("Note: IRR accounts for the timing of all contributions")

    print(f"\nPortfolio (Investment Mix):")
    print(f"  Mean IRR:         {np.mean(irr_returns):>6.2f}%")
    print(f"  Median IRR:       {np.median(irr_returns):>6.2f}%")
    print(f"  Std Dev:          {np.std(irr_returns):>6.2f}%")
    print(f"  Min:              {np.min(irr_returns):>6.2f}%")
    print(f"  Max:              {np.max(irr_returns):>6.2f}%")
    print(f"  25th percentile:  {np.percentile(irr_returns, 25):>6.2f}%")
    print(f"  75th percentile:  {np.percentile(irr_returns, 75):>6.2f}%")

    print(f"\nBaseline (HYSA only):")
    print(f"  Mean IRR:         {np.mean(baseline_irr_returns):>6.2f}%")
    print(f"  Median IRR:       {np.median(baseline_irr_returns):>6.2f}%")

    print(f"\nIRR difference (Portfolio - Baseline):")
    print(f"  Mean:   {np.mean(irr_returns) - np.mean(baseline_irr_returns):>6.2f}%")
    print(f"  Median: {np.median(irr_returns) - np.median(baseline_irr_returns):>6.2f}%")

    # ==================== MILESTONE ANALYSIS ====================
    print(f"\n{'='*70}")
    print("PORTFOLIO VALUE AT KEY MILESTONES")
    print(f"{'='*70}")

    milestones = [3, 5, 7, 10, 15]

    for year in milestones:
        stats = calculate_milestone_statistics(simulation_results, year)
        print(f"\nYear {year}:")
        print(f"  25th percentile: ${stats['p25']:>12,.2f}")
        print(f"  50th percentile: ${stats['p50']:>12,.2f}  (Median)")
        print(f"  75th percentile: ${stats['p75']:>12,.2f}")
        print(f"  Baseline:        ${stats['avg_baseline']:>12,.2f}")
        print(f"  Beat baseline:   {stats['beat_baseline_pct']:>11.2f}%")
        print(f"  Median gain:     ${stats['median_gain']:>12,.2f}")

    # ==================== VARIANCE ANALYSIS ====================
    print(f"\n{'='*70}")
    print("SEQUENCES WITH HIGHEST VARIANCE (most uncertainty):")
    print(f"{'='*70}")

    sorted_by_variance = calculate_sequence_variances(final_values, sequence_indices, complete_sequences)
    for i, (seq_idx, start, end, var) in enumerate(sorted_by_variance[:5], 1):
        print(f"  {i}. {start}-{end}: Std Dev ${var:>12,.2f}")

    # ==================== MILESTONE COMPARISON TABLE ====================
    print(f"\n{'='*70}")
    print("MILESTONE COMPARISON TABLE")
    print(f"{'='*70}")
    print(f"{'Year':<6} {'25th %ile':<15} {'Median':<15} {'75th %ile':<15} {'Baseline':<15} {'Beat %':<10}")
    print("-" * 70)

    for year in milestones:
        stats = calculate_milestone_statistics(simulation_results, year)
        print(f"{year:<6} ${stats['p25']/1000:>6.1f}K{'':<7} "
              f"${stats['p50']/1000:>6.1f}K{'':<7} "
              f"${stats['p75']/1000:>6.1f}K{'':<7} "
              f"${stats['avg_baseline']/1000:>6.1f}K{'':<7} "
              f"{stats['beat_baseline_pct']:>6.2f}%")

    print("="*70)

def calculate_fund_returns(simulation_results, time_to_new_job, time_to_kid,
                          starting_contribution, next_job_contribution,
                          after_kid_contribution, investment_mix):
    """
    Calculate annualized returns for each individual fund.

    Parameters:
    -----------
    simulation_results : dict
        Dictionary containing simulation results
    time_to_new_job : int
        Months until new job
    time_to_kid : int
        Months until kid
    starting_contribution : float
        Initial monthly contribution
    next_job_contribution : float
        New job monthly contribution
    after_kid_contribution : float
        After kid monthly contribution
    investment_mix : dict
        Investment allocation percentages

    Returns:
    --------
    dict : Dictionary containing arrays of returns for each fund
    """
    sp500_returns = []
    nasdaq_returns = []
    tbill_returns = []
    hysa_returns = []
    emergency_returns = []

    print("\nCalculating individual fund returns...")

    for idx, result_dict in enumerate(simulation_results['result_dict']):
        if idx % 10000 == 0 and idx > 0:
            print(f"  Processed {idx:,} / {len(simulation_results['result_dict']):,} simulations...")

        # Calculate total contributions over time
        total_months = len(result_dict['Month_Index']) - 1
        total_contribution = 0
        for month in range(total_months):
            if month < time_to_new_job:
                total_contribution += starting_contribution
            elif month < time_to_kid:
                total_contribution += next_job_contribution
            else:
                total_contribution += after_kid_contribution

        # S&P 500
        sp500_initial = result_dict['SP500'][0]
        sp500_final = result_dict['SP500'][-1]
        sp500_contributions = total_contribution * investment_mix['SP500']
        sp500_total_invested = sp500_initial + sp500_contributions
        if sp500_total_invested > 0:
            sp500_return = ((sp500_final / sp500_total_invested) ** (1/15) - 1) * 100
            sp500_returns.append(sp500_return)

        # NASDAQ 100
        nasdaq_initial = result_dict['NASDAQ100'][0]
        nasdaq_final = result_dict['NASDAQ100'][-1]
        nasdaq_contributions = total_contribution * investment_mix['NASDAQ']
        nasdaq_total_invested = nasdaq_initial + nasdaq_contributions
        if nasdaq_total_invested > 0:
            nasdaq_return = ((nasdaq_final / nasdaq_total_invested) ** (1/15) - 1) * 100
            nasdaq_returns.append(nasdaq_return)

        # T-Bills
        tbill_initial = result_dict['TBILL_3M'][0]
        tbill_final = result_dict['TBILL_3M'][-1]
        tbill_contributions = total_contribution * investment_mix['TBill']
        tbill_total_invested = tbill_initial + tbill_contributions
        if tbill_total_invested > 0:
            tbill_return = ((tbill_final / tbill_total_invested) ** (1/15) - 1) * 100
            tbill_returns.append(tbill_return)

        # HYSA
        hysa_initial = result_dict['HYSA'][0]
        hysa_final = result_dict['HYSA'][-1]
        hysa_contributions = total_contribution * investment_mix['HYSA']
        hysa_total_invested = hysa_initial + hysa_contributions
        if hysa_total_invested > 0:
            hysa_return = ((hysa_final / hysa_total_invested) ** (1/15) - 1) * 100
            hysa_returns.append(hysa_return)

        # Emergency Fund (no contributions, just grows with HYSA rate)
        emergency_initial = result_dict['Emergency_fund'][0]
        emergency_final = result_dict['Emergency_fund'][-1]
        if emergency_initial > 0:
            emergency_return = ((emergency_final / emergency_initial) ** (1/15) - 1) * 100
            emergency_returns.append(emergency_return)

    return {
        'SP500': np.array(sp500_returns),
        'NASDAQ100': np.array(nasdaq_returns),
        'TBILL_3M': np.array(tbill_returns),
        'HYSA': np.array(hysa_returns),
        'Emergency_fund': np.array(emergency_returns)
    }


def print_fund_returns_summary(fund_returns, simulation_name=""):
    """
    Print summary statistics for individual fund returns.

    Parameters:
    -----------
    fund_returns : dict
        Dictionary of fund return arrays
    simulation_name : str
        Name of simulation (optional)
    """
    print("\n" + "="*70)
    if simulation_name:
        print(f"INDIVIDUAL FUND RETURNS - {simulation_name}")
    else:
        print("INDIVIDUAL FUND RETURNS")
    print("="*70)

    funds = ['SP500', 'NASDAQ100', 'TBILL_3M', 'HYSA', 'Emergency_fund']
    fund_names = ['S&P 500', 'NASDAQ 100', '3-Month T-Bills', 'HYSA', 'Emergency Fund']

    for fund, name in zip(funds, fund_names):
        if len(fund_returns[fund]) > 0:
            print(f"\n{name}:")
            print(f"  Mean return:      {np.mean(fund_returns[fund]):>6.2f}%")
            print(f"  Median return:    {np.median(fund_returns[fund]):>6.2f}%")
            print(f"  Std Dev:          {np.std(fund_returns[fund]):>6.2f}%")
            print(f"  Min:              {np.min(fund_returns[fund]):>6.2f}%")
            print(f"  Max:              {np.max(fund_returns[fund]):>6.2f}%")
            print(f"  25th percentile:  {np.percentile(fund_returns[fund], 25):>6.2f}%")
            print(f"  75th percentile:  {np.percentile(fund_returns[fund], 75):>6.2f}%")

    print("="*70)

"""## Simulation Functions"""

def calculate_monthly_return(yearly_return, std):
    '''
    Get the monthly return from the annual return. Include some noise for more realism. So it will be based on historical data but vary depending on the monthly noise to provide a range of outcomes.
    '''
    avg_monthly_return = (1 + yearly_return)**(1/12) - 1
    actual_monthly_return = []
    for i in range(0,12):
        actual_return = avg_monthly_return + np.random.normal(0, std)
        actual_monthly_return.append(actual_return)
    return actual_monthly_return

def get_15_year_sequences(market_returns):
    '''
    Get all unique 15-year sequences from the market returns data.

    Parameters:
    -----------
    market_returns : dict
        Dictionary containing 'SP500', 'NASDAQ100', and 'TBILL_3M' with year: return pairs

    Returns:
    --------
    list of dict
        Each dict contains:
        - 'start_year': int
        - 'end_year': int
        - 'SP500': list of 15 annual returns
        - 'NASDAQ100': list of 15 annual returns (or None if data not available)
        - 'TBILL_3M': list of 15 annual returns (or None if data not available)
    '''
    sequences = []

    # Get the years available for each fund
    sp500_years = sorted(market_returns['SP500'].keys())
    nasdaq_years = sorted(market_returns['NASDAQ100'].keys())
    tbill_years = sorted(market_returns['TBILL_3M'].keys())

    # Find the earliest and latest years across all funds
    earliest_year = min(sp500_years[0], nasdaq_years[0], tbill_years[0])
    latest_year = max(sp500_years[-1], nasdaq_years[-1], tbill_years[-1])

    # Iterate through all possible 15-year windows
    for start_year in range(earliest_year, latest_year - 14):
        end_year = start_year + 14  # 15 years inclusive

        sequence = {
            'start_year': start_year,
            'end_year': end_year,
            'SP500': [],
            'NASDAQ100': [],
            'TBILL_3M': []
        }

        # Check if we have complete data for this 15-year period
        has_sp500 = all(year in sp500_years for year in range(start_year, end_year + 1))
        has_nasdaq = all(year in nasdaq_years for year in range(start_year, end_year + 1))
        has_tbill = all(year in tbill_years for year in range(start_year, end_year + 1))

        # Collect the returns for each fund (if available)
        if has_sp500:
            sequence['SP500'] = [market_returns['SP500'][year] for year in range(start_year, end_year + 1)]
        else:
            sequence['SP500'] = None

        if has_nasdaq:
            sequence['NASDAQ100'] = [market_returns['NASDAQ100'][year] for year in range(start_year, end_year + 1)]
        else:
            sequence['NASDAQ100'] = None

        if has_tbill:
            sequence['TBILL_3M'] = [market_returns['TBILL_3M'][year] for year in range(start_year, end_year + 1)]
        else:
            sequence['TBILL_3M'] = None

        sequences.append(sequence)

    return sequences

def run_investment_simulation(investment_mix, investment_start, emergency_fund_start,
                               complete_sequences, total_iterations,
                               hysa_apy, SP500_std, NASDAQ_std, T_Bills_std,
                               time_to_new_job, time_to_kid,
                               starting_contribution, next_job_contribution,
                               after_kid_contribution,
                               simulation_name="Investment Simulation"):
    """
    Run a complete investment simulation with a given investment mix.

    Parameters:
    -----------
    investment_mix : dict
        Investment allocation percentages (keys: 'SP500', 'NASDAQ', 'TBill', 'HYSA')
    investment_start : float
        Initial investment amount
    emergency_fund_start : float
        Initial emergency fund amount
    complete_sequences : list
        List of historical 15-year sequences
    total_iterations : int
        Number of iterations to run per sequence
    hysa_apy : float
        Annual percentage yield for HYSA
    SP500_std : float
        Standard deviation for S&P 500 monthly volatility
    NASDAQ_std : float
        Standard deviation for NASDAQ 100 monthly volatility
    T_Bills_std : float
        Standard deviation for T-Bill monthly volatility
    time_to_new_job : int
        Months until new job starts
    time_to_kid : int
        Months until kid arrives
    starting_contribution : float
        Initial monthly contribution
    next_job_contribution : float
        Monthly contribution after new job
    after_kid_contribution : float
        Monthly contribution after kid
    simulation_name : str
        Name for the simulation (for display purposes)

    Returns:
    --------
    dict : Simulation results containing iteration data and result dictionaries
    """

    print(f"\n{'='*70}")
    print(f"RUNNING SIMULATION: {simulation_name}")
    print(f"{'='*70}")
    print(f"Investment Mix:")
    print(f"  S&P 500:   {investment_mix['SP500']*100:.1f}%")
    print(f"  NASDAQ:    {investment_mix['NASDAQ']*100:.1f}%")
    print(f"  T-Bills:   {investment_mix['TBill']*100:.1f}%")
    print(f"  HYSA:      {investment_mix['HYSA']*100:.1f}%")
    print(f"\nInitial Values:")
    print(f"  Investment: ${investment_start:,.2f}")
    print(f"  Emergency:  ${emergency_fund_start:,.2f}")
    print(f"\nRunning {total_iterations:,} iterations across {len(complete_sequences)} sequences...")
    print(f"{'='*70}\n")

    simulation_results = {
        'iteration': [],
        'sequence_index': [],
        'sequence_start_year': [],
        'sequence_end_year': [],
        'result_dict': [],
        'simulation_name': simulation_name,
        'investment_mix': investment_mix
    }

    # HYSA returns are constant
    HYSA_monthly_returns = calculate_monthly_return(hysa_apy, 0)[0]

    # Loop through each sequence
    for seq_idx, seq in enumerate(complete_sequences):

        if seq_idx % 5 == 0:
            print(f"Processing sequence {seq_idx + 1}/{len(complete_sequences)}: {seq['start_year']}-{seq['end_year']}")

        # Run iterations for this sequence
        for iteration in range(0, total_iterations):

            # Set up the initial investment mix
            investment_breakdown = {
                'Month_Index': [0],
                'SP500': [investment_start * investment_mix['SP500']],
                'NASDAQ100': [investment_start * investment_mix['NASDAQ']],
                'TBILL_3M': [investment_start * investment_mix['TBill']],
                'HYSA': [investment_start * investment_mix['HYSA']],
                'Emergency_fund': [emergency_fund_start],
                'Baseline': [investment_start + emergency_fund_start]
            }

            # Loop through ALL 15 years in the sequence
            for year_idx in range(15):
                # Get monthly returns for THIS year with random sampling
                sp500_monthly_returns = calculate_monthly_return(seq['SP500'][year_idx]/100, SP500_std)
                nasdaq_monthly_returns = calculate_monthly_return(seq['NASDAQ100'][year_idx]/100, NASDAQ_std)
                TBILL_3M_monthly_returns = calculate_monthly_return(seq['TBILL_3M'][year_idx]/100, T_Bills_std)

                # Simulate 12 months within this year
                for month_idx in range(12):
                    # Determine contribution amount based on month
                    current_month = investment_breakdown['Month_Index'][-1]
                    if current_month < time_to_new_job:
                        contribution = starting_contribution
                    elif current_month < time_to_kid:
                        contribution = next_job_contribution
                    else:
                        contribution = after_kid_contribution

                    # Calculate contribution for each investment type
                    sp500_contribution = contribution * investment_mix['SP500']
                    nasdaq_contribution = contribution * investment_mix['NASDAQ']
                    tbill_contribution = contribution * investment_mix['TBill']
                    hysa_contribution = contribution * investment_mix['HYSA']

                    # Update month index
                    investment_breakdown['Month_Index'].append(current_month + 1)

                    # Apply returns AND add contributions
                    new_sp500 = (investment_breakdown['SP500'][-1] + sp500_contribution) * (1 + sp500_monthly_returns[month_idx])
                    new_nasdaq = (investment_breakdown['NASDAQ100'][-1] + nasdaq_contribution) * (1 + nasdaq_monthly_returns[month_idx])
                    new_tbill = (investment_breakdown['TBILL_3M'][-1] + tbill_contribution) * (1 + TBILL_3M_monthly_returns[month_idx])
                    new_hysa = (investment_breakdown['HYSA'][-1] + hysa_contribution) * (1 + HYSA_monthly_returns)
                    new_baseline = (investment_breakdown['Baseline'][-1] + contribution) * (1 + HYSA_monthly_returns)

                    investment_breakdown['SP500'].append(new_sp500)
                    investment_breakdown['NASDAQ100'].append(new_nasdaq)
                    investment_breakdown['TBILL_3M'].append(new_tbill)
                    investment_breakdown['HYSA'].append(new_hysa)

                    # Emergency fund and baseline
                    investment_breakdown['Emergency_fund'].append(investment_breakdown['Emergency_fund'][-1] * (1 + HYSA_monthly_returns))
                    investment_breakdown['Baseline'].append(new_baseline)

            # After completing all 15 years, save the result
            simulation_results['iteration'].append(iteration)
            simulation_results['sequence_index'].append(seq_idx)
            simulation_results['sequence_start_year'].append(seq['start_year'])
            simulation_results['sequence_end_year'].append(seq['end_year'])
            simulation_results['result_dict'].append(investment_breakdown)

    print(f"\nSimulation complete!")
    print(f"Total sequences: {len(complete_sequences)}")
    print(f"Iterations per sequence: {total_iterations}")
    print(f"Total simulation results: {len(simulation_results['iteration'])}")

    return simulation_results

"""# Runtime Parameters"""

# Standard Deviations for Different markets
SP500_std = 0.045
NASDAQ_std = 0.07
T_Bills_std = 0.002

# Starting amounts
emergency_fund_start = 25000
investment_start = 50000

# High Yield Savings APY
hysa_apy = 0.035

# Moderately aggressive
investment_mix_1 = {'SP500': 0.45,
                    'NASDAQ': 0.35,
                    'TBill': 0.05,
                    'HYSA': 0.15}

# Moderately conservative
investment_mix_2 = {'SP500': 0.3,
                    'NASDAQ': 0.2,
                    'TBill': 0.05,
                    'HYSA': 0.45}


# Monthly contribution
starting_contribution = 3200
next_job_contribution = 4000
after_kid_contribution = 1000

# Time til future events (months)
time_to_new_job = 7
time_to_kid = 20

total_iterations = 1000

"""# Data creation"""

market_returns = {
    'SP500': {
        1926: 11.62, 1927: 37.49, 1928: 43.61, 1929: -8.42, 1930: -24.90,
        1931: -43.34, 1932: -8.19, 1933: 53.99, 1934: -1.44, 1935: 47.67,
        1936: 33.92, 1937: -35.03, 1938: 31.12, 1939: -0.41, 1940: -9.78,
        1941: -11.59, 1942: 20.34, 1943: 25.90, 1944: 19.75, 1945: 36.44,
        1946: -8.07, 1947: 5.71, 1948: 5.50, 1949: 18.79, 1950: 31.71,
        1951: 24.02, 1952: 18.37, 1953: -0.99, 1954: 52.62, 1955: 31.56,
        1956: 6.56, 1957: -10.78, 1958: 43.36, 1959: 11.96, 1960: 0.47,
        1961: 26.89, 1962: -8.73, 1963: 22.80, 1964: 16.48, 1965: 12.45,
        1966: -10.06, 1967: 23.98, 1968: 11.06, 1969: -8.50, 1970: 4.01,
        1971: 14.31, 1972: 18.98, 1973: -14.66, 1974: -26.47, 1975: 37.20,
        1976: 23.84, 1977: -7.18, 1978: 6.56, 1979: 18.44, 1980: 32.42,
        1981: -4.91, 1982: 21.55, 1983: 22.56, 1984: 6.27, 1985: 31.73,
        1986: 18.67, 1987: 5.25, 1988: 16.61, 1989: 31.69, 1990: -3.10,
        1991: 30.47, 1992: 7.62, 1993: 10.08, 1994: 1.32, 1995: 37.58,
        1996: 22.96, 1997: 33.36, 1998: 28.58, 1999: 21.04, 2000: -9.10,
        2001: -11.89, 2002: -22.10, 2003: 28.68, 2004: 10.88, 2005: 4.91,
        2006: 15.79, 2007: 5.49, 2008: -37.00, 2009: 26.46, 2010: 15.06,
        2011: 2.11, 2012: 16.00, 2013: 32.39, 2014: 13.69, 2015: 1.38,
        2016: 11.96, 2017: 21.83, 2018: -4.38, 2019: 31.49, 2020: 18.40,
        2021: 28.71, 2022: -18.11, 2023: 26.29, 2024: 25.02
    },
    'NASDAQ100': {
        1986: 6.89, 1987: 10.50, 1988: 13.54, 1989: 26.17, 1990: -10.41,
        1991: 64.99, 1992: 8.87, 1993: 10.58, 1994: 1.50, 1995: 42.54,
        1996: 42.54, 1997: 20.63, 1998: 85.31, 1999: 101.95, 2000: -36.84,
        2001: -32.65, 2002: -37.58, 2003: 49.12, 2004: 10.44, 2005: 1.49,
        2006: 6.79, 2007: 18.67, 2008: -41.89, 2009: 53.54, 2010: 19.22,
        2011: 2.70, 2012: 16.82, 2013: 34.99, 2014: 17.94, 2015: 8.43,
        2016: 5.89, 2017: 31.52, 2018: -1.04, 2019: 37.96, 2020: 47.58,
        2021: 26.63, 2022: -32.97, 2023: 53.81, 2024: 24.88
    },
    'TBILL_3M': {
        1928: 3.08, 1929: 3.16, 1930: 4.55, 1931: 2.31, 1932: 1.07,
        1933: 0.96, 1934: 0.28, 1935: 0.17, 1936: 0.17, 1937: 0.28,
        1938: 0.07, 1939: 0.05, 1940: 0.04, 1941: 0.13, 1942: 0.34,
        1943: 0.38, 1944: 0.38, 1945: 0.38, 1946: 0.38, 1947: 0.60,
        1948: 1.05, 1949: 1.12, 1950: 1.20, 1951: 1.52, 1952: 1.72,
        1953: 1.89, 1954: 0.94, 1955: 1.72, 1956: 2.62, 1957: 3.22,
        1958: 1.77, 1959: 3.39, 1960: 2.87, 1961: 2.35, 1962: 2.77,
        1963: 3.16, 1964: 3.55, 1965: 3.95, 1966: 4.86, 1967: 4.29,
        1968: 5.34, 1969: 6.67, 1970: 6.39, 1971: 4.33, 1972: 4.06,
        1973: 7.04, 1974: 7.85, 1975: 5.79, 1976: 4.98, 1977: 5.26,
        1978: 7.18, 1979: 10.05, 1980: 11.39, 1981: 14.04, 1982: 10.60,
        1983: 8.62, 1984: 9.54, 1985: 7.47, 1986: 5.97, 1987: 5.78,
        1988: 6.67, 1989: 8.11, 1990: 7.50, 1991: 5.38, 1992: 3.43,
        1993: 3.00, 1994: 4.25, 1995: 5.49, 1996: 5.01, 1997: 5.06,
        1998: 4.78, 1999: 4.64, 2000: 5.82, 2001: 3.40, 2002: 1.61,
        2003: 1.01, 2004: 1.37, 2005: 3.15, 2006: 4.73, 2007: 4.36,
        2008: 1.37, 2009: 0.15, 2010: 0.14, 2011: 0.05, 2012: 0.09,
        2013: 0.06, 2014: 0.03, 2015: 0.05, 2016: 0.32, 2017: 0.93,
        2018: 1.94, 2019: 2.06, 2020: 0.35, 2021: 0.05, 2022: 2.02,
        2023: 5.07, 2024: 4.97
    }
}

# Create DataFrames for easier plotting
sp500_df = pd.DataFrame(list(market_returns['SP500'].items()), columns=['Year', 'Return'])
nasdaq_df = pd.DataFrame(list(market_returns['NASDAQ100'].items()), columns=['Year', 'Return'])
tbill_df = pd.DataFrame(list(market_returns['TBILL_3M'].items()), columns=['Year', 'Return'])

"""# Exploration"""

# ==================== HISTOGRAMS ====================
fig, axes = plt.subplots(1, 3, figsize=(15, 5))

# S&P 500 Histogram
sns.histplot(sp500_df['Return'], bins=30, kde=False, color='steelblue', ax=axes[0])
axes[0].set_xlabel('Annual Return (%)')
axes[0].set_ylabel('Frequency')
axes[0].set_title('S&P 500 Return Distribution (1926-2024)')
axes[0].axvline(sp500_df['Return'].mean(), color='red', linestyle='--',
                label=f"Mean: {sp500_df['Return'].mean():.2f}%")
axes[0].legend()

# NASDAQ 100 Histogram
sns.histplot(nasdaq_df['Return'], bins=30, kde=False, color='green', ax=axes[1])
axes[1].set_xlabel('Annual Return (%)')
axes[1].set_ylabel('Frequency')
axes[1].set_title('NASDAQ 100 Return Distribution (1986-2024)')
axes[1].axvline(nasdaq_df['Return'].mean(), color='red', linestyle='--',
                label=f"Mean: {nasdaq_df['Return'].mean():.2f}%")
axes[1].legend()

# 3-Month T-Bill Histogram
sns.histplot(tbill_df['Return'], bins=30, kde=False, color='orange', ax=axes[2])
axes[2].set_xlabel('Annual Return (%)')
axes[2].set_ylabel('Frequency')
axes[2].set_title('3-Month T-Bill Return Distribution (1928-2024)')
axes[2].axvline(tbill_df['Return'].mean(), color='red', linestyle='--',
                label=f"Mean: {tbill_df['Return'].mean():.2f}%")
axes[2].legend()

plt.tight_layout()
plt.show()

# ==================== LINE PLOT (Returns by Year) ====================
plt.figure(figsize=(14, 7))

# Plot each fund
plt.plot(sp500_df['Year'], sp500_df['Return'], label='S&P 500',
         linewidth=2, color='steelblue')
plt.plot(nasdaq_df['Year'], nasdaq_df['Return'], label='NASDAQ 100',
         linewidth=2, color='green')
plt.plot(tbill_df['Year'], tbill_df['Return'], label='3-Month T-Bill',
         linewidth=2, color='orange')

# Add a horizontal line at 0%
plt.axhline(0, color='black', linestyle='--', linewidth=0.8, alpha=0.5)

plt.xlabel('Year', fontsize=12)
plt.ylabel('Annual Return (%)', fontsize=12)
plt.title('Historical Annual Returns by Fund (1928-2024)', fontsize=14, fontweight='bold')
plt.legend(fontsize=11)
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

"""# Get 15 year Sequences"""

sequences = get_15_year_sequences(market_returns)

# Print some info about the sequences
print(f"Total number of 15-year sequences: {len(sequences)}")
print(f"\nFirst sequence: {sequences[0]['start_year']}-{sequences[0]['end_year']}")
print(f"Has SP500 data: {sequences[0]['SP500'] is not None}")
print(f"Has NASDAQ100 data: {sequences[0]['NASDAQ100'] is not None}")
print(f"Has TBILL_3M data: {sequences[0]['TBILL_3M'] is not None}")

print(f"\nLast sequence: {sequences[-1]['start_year']}-{sequences[-1]['end_year']}")
print(f"Has SP500 data: {sequences[-1]['SP500'] is not None}")
print(f"Has NASDAQ100 data: {sequences[-1]['NASDAQ100'] is not None}")
print(f"Has TBILL_3M data: {sequences[-1]['TBILL_3M'] is not None}")

# Example: Print the first sequence that has all three funds
for seq in sequences:
    if seq['SP500'] and seq['NASDAQ100'] and seq['TBILL_3M']:
        print(f"\nFirst sequence with all three funds: {seq['start_year']}-{seq['end_year']}")
        print(f"SP500 returns: {seq['SP500']}")
        break

# Filter to only those with all three funds
complete_sequences = [seq for seq in sequences
                     if seq['SP500'] is not None
                     and seq['NASDAQ100'] is not None
                     and seq['TBILL_3M'] is not None]

"""# Simulate Moderately Aggressive Sequence"""

# Run aggressive scenario
results_aggressive = run_investment_simulation(
    investment_mix=investment_mix_1,
    investment_start=investment_start,
    emergency_fund_start=emergency_fund_start,
    complete_sequences=complete_sequences,
    total_iterations=total_iterations,
    hysa_apy=hysa_apy,
    SP500_std=SP500_std,
    NASDAQ_std=NASDAQ_std,
    T_Bills_std=T_Bills_std,
    time_to_new_job=time_to_new_job,
    time_to_kid=time_to_kid,
    starting_contribution=starting_contribution,
    next_job_contribution=next_job_contribution,
    after_kid_contribution=after_kid_contribution,
    simulation_name="Moderately Aggressive"
)

"""## Summary Statistics"""

# HYSA Monthly Returns
HYSA_monthly_returns = calculate_monthly_return(hysa_apy, 0)[0]

# Extract data from simulation results
data = extract_simulation_data(results_aggressive)

# Calculate IRR for all simulations
irr_data = calculate_all_irrs(results_aggressive, time_to_new_job, time_to_kid,
                               starting_contribution, next_job_contribution,
                               after_kid_contribution, HYSA_monthly_returns)

# Print comprehensive summary statistics
print_summary_statistics(results_aggressive, data, irr_data, complete_sequences,
                        total_iterations, time_to_new_job, time_to_kid,
                        starting_contribution, next_job_contribution, after_kid_contribution)

# Calculate fund returns for conservative portfolio
fund_returns_aggressive = calculate_fund_returns(
    results_aggressive,
    time_to_new_job,
    time_to_kid,
    starting_contribution,
    next_job_contribution,
    after_kid_contribution,
    investment_mix_1
)

# Print summary
print_fund_returns_summary(fund_returns_aggressive, "Moderately Aggressive")

"""## Plots

### Analysis Data Prep
"""

# Extract final values and create time series data
final_values = []
all_timeseries = []  # Store month-by-month total values
baselines = []
sequence_indices = []

for i, result_dict in enumerate(simulation_results['result_dict']):
    # Calculate total value (excluding baseline)
    final_total = (result_dict['SP500'][-1] +
                   result_dict['NASDAQ100'][-1] +
                   result_dict['TBILL_3M'][-1] +
                   result_dict['HYSA'][-1] +
                   result_dict['Emergency_fund'][-1])
    final_values.append(final_total)
    baselines.append(result_dict['Baseline'][-1])
    sequence_indices.append(simulation_results['sequence_index'][i])

    # Calculate total value at each month
    timeseries = []
    for j in range(len(result_dict['Month_Index'])):
        total = (result_dict['SP500'][j] +
                 result_dict['NASDAQ100'][j] +
                 result_dict['TBILL_3M'][j] +
                 result_dict['HYSA'][j] +
                 result_dict['Emergency_fund'][j])
        timeseries.append(total)
    all_timeseries.append(timeseries)

# Convert to numpy arrays for easier manipulation
final_values = np.array(final_values)
baselines = np.array(baselines)
sequence_indices = np.array(sequence_indices)

# Calculate % of outcomes that beat baseline
beat_baseline = np.sum(final_values > baselines) / len(final_values) * 100
print(f"Percentage of outcomes that beat baseline: {beat_baseline:.2f}%")

"""### Median for each sequence"""

fig, ax = plt.subplots(figsize=(14, 8))

# Convert months to years for x-axis
max_months = 181  # 15 years * 12 months + 1 for month 0
years = np.arange(max_months) / 12

# Calculate median trajectory for each sequence
sequence_medians = []
for seq_idx in range(len(complete_sequences)):
    # Get all iterations for this sequence
    mask = sequence_indices == seq_idx
    seq_timeseries = []

    for j in np.where(mask)[0]:
        result_dict = simulation_results['result_dict'][j]
        timeseries = []
        for k in range(len(result_dict['Month_Index'])):
            total = (result_dict['SP500'][k] + result_dict['NASDAQ100'][k] +
                    result_dict['TBILL_3M'][k] + result_dict['HYSA'][k] +
                    result_dict['Emergency_fund'][k])
            timeseries.append(total)
        seq_timeseries.append(timeseries)

    # Calculate median for this sequence
    if len(seq_timeseries) > 0:
        seq_array = np.array(seq_timeseries)
        seq_median = np.median(seq_array, axis=0)
        sequence_medians.append(seq_median)

        # Plot this sequence's median in faint color
        years_plot = np.arange(len(seq_median)) / 12
        ax.plot(years_plot, seq_median, color='blue', alpha=0.15, linewidth=1)

# Calculate overall median across all simulations
timeseries_array = np.array([ts for ts in all_timeseries if len(ts) == max_months])
overall_median = np.median(timeseries_array, axis=0)

# Plot overall median line (darker, thicker)
ax.plot(years[:len(overall_median)], overall_median, color='darkblue', linewidth=3,
        label='Overall Median', zorder=100)

# Plot baseline
baseline_timeseries = np.array([simulation_results['result_dict'][0]['Baseline'][j]
                                for j in range(max_months)])
ax.plot(years, baseline_timeseries, color='red', linewidth=3,
        label='Baseline (HYSA only)', linestyle='--', zorder=100)

# Add vertical lines at 5 and 10 years
ax.axvline(5, color='gray', linestyle=':', linewidth=2, alpha=0.7, label='5 Years')
ax.axvline(10, color='gray', linestyle=':', linewidth=2, alpha=0.7, label='10 Years')

# Set appropriate axis limits
ax.set_xlim(0, 15)
y_max = max(np.max(overall_median), np.max(baseline_timeseries)) * 1.1
y_min = min(np.min(overall_median), np.min(baseline_timeseries)) * 0.9
ax.set_ylim(y_min, y_max)

ax.set_xlabel('Years', fontsize=12)
ax.set_ylabel('Total Portfolio Value ($)', fontsize=12)
ax.set_title(f'Median Outcome by Historical Sequence\n({len(complete_sequences)} sequences, 10,000 iterations each)',
             fontsize=14, fontweight='bold')
ax.legend(fontsize=11, loc='upper left')
ax.grid(True, alpha=0.3)
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))

plt.tight_layout()
plt.show()

"""### All simulations with median"""

fig, ax = plt.subplots(figsize=(14, 8))

# Plot all simulations with very faint lines
for timeseries in all_timeseries:
    if len(timeseries) == max_months:
        years_plot = np.arange(len(timeseries)) / 12
        ax.plot(years_plot, timeseries, color='blue', alpha=0.005, linewidth=0.3)

# Calculate percentiles
percentile_25 = np.percentile(timeseries_array, 25, axis=0)
percentile_75 = np.percentile(timeseries_array, 75, axis=0)
median_timeseries = np.median(timeseries_array, axis=0)

# Plot percentile bands
years_plot = np.arange(len(median_timeseries)) / 12
ax.fill_between(years_plot, percentile_25, percentile_75, color='blue', alpha=0.2,
                label='25th-75th Percentile')

# Plot median line
ax.plot(years_plot, median_timeseries, color='darkblue', linewidth=3,
        label='Median Outcome', zorder=100)

# Plot baseline
ax.plot(years, baseline_timeseries, color='red', linewidth=3,
        label='Baseline (HYSA only)', linestyle='--', zorder=100)

# Add vertical lines at 5 and 10 years
ax.axvline(5, color='gray', linestyle=':', linewidth=2, alpha=0.7, label='5 Years')
ax.axvline(10, color='gray', linestyle=':', linewidth=2, alpha=0.7, label='10 Years')

# Set appropriate axis limits
ax.set_xlim(0, 15)
y_max_all = np.percentile(timeseries_array[:, -1], 95)  # Use 95th percentile to avoid outliers
y_min_all = np.percentile(timeseries_array[:, 0], 5)   # Use 5th percentile
ax.set_ylim(y_min_all * 0.9, y_max_all * 1.1)

ax.set_xlabel('Years', fontsize=12)
ax.set_ylabel('Total Portfolio Value ($)', fontsize=12)
ax.set_title(f'All Simulation Outcomes - {len(complete_sequences)} Sequences Ã— 10,000 Iterations',
             fontsize=14, fontweight='bold')
ax.legend(fontsize=11, loc='upper left')
ax.grid(True, alpha=0.3)
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))

plt.tight_layout()
plt.show()

"""### Histogram"""

fig, ax = plt.subplots(figsize=(12, 7))

# Plot histogram
n, bins, patches = ax.hist(final_values/1000, bins=100, color='steelblue',
                           edgecolor='black', alpha=0.7)

# Add vertical lines for key statistics
median_val = np.median(final_values)
mean_val = np.mean(final_values)
baseline_val = np.mean(baselines)
percentile_10 = np.percentile(final_values, 10)
percentile_90 = np.percentile(final_values, 90)

ax.axvline(median_val/1000, color='darkblue', linestyle='--', linewidth=2,
          label=f'Median: ${median_val/1000:.1f}K')
ax.axvline(mean_val/1000, color='blue', linestyle='--', linewidth=2,
          label=f'Mean: ${mean_val/1000:.1f}K')
ax.axvline(baseline_val/1000, color='red', linestyle='--', linewidth=2,
          label=f'Baseline: ${baseline_val/1000:.1f}K')
ax.axvline(percentile_10/1000, color='orange', linestyle=':', linewidth=2,
          label=f'10th percentile: ${percentile_10/1000:.1f}K')
ax.axvline(percentile_90/1000, color='purple', linestyle=':', linewidth=2,
          label=f'90th percentile: ${percentile_90/1000:.1f}K')

ax.set_xlabel('Final Portfolio Value ($1000s)', fontsize=12)
ax.set_ylabel('Frequency', fontsize=12)
ax.set_title(f'Distribution of Final Outcomes After 15 Years\n{beat_baseline:.1f}% of outcomes beat baseline',
            fontsize=14, fontweight='bold')
ax.legend(fontsize=10, loc='upper right')
ax.grid(axis='y', alpha=0.3)

plt.tight_layout()
plt.show()

"""# Sim Moderately Conservative"""

# Run conservative scenario
results_conservative = run_investment_simulation(
    investment_mix=investment_mix_2,
    investment_start=investment_start,
    emergency_fund_start=emergency_fund_start,
    complete_sequences=complete_sequences,
    total_iterations=total_iterations,
    hysa_apy=hysa_apy,
    SP500_std=SP500_std,
    NASDAQ_std=NASDAQ_std,
    T_Bills_std=T_Bills_std,
    time_to_new_job=time_to_new_job,
    time_to_kid=time_to_kid,
    starting_contribution=starting_contribution,
    next_job_contribution=next_job_contribution,
    after_kid_contribution=after_kid_contribution,
    simulation_name="Moderately Conservative"
)

"""## Summary Statistics"""

# HYSA Monthly Returns
HYSA_monthly_returns = calculate_monthly_return(hysa_apy, 0)[0]

# Extract data from simulation results
data = extract_simulation_data(results_conservative)

# Calculate IRR for all simulations
irr_data = calculate_all_irrs(results_conservative, time_to_new_job, time_to_kid,
                               starting_contribution, next_job_contribution,
                               after_kid_contribution, HYSA_monthly_returns)

# Print comprehensive summary statistics
print_summary_statistics(results_conservative, data, irr_data, complete_sequences,
                        total_iterations, time_to_new_job, time_to_kid,
                        starting_contribution, next_job_contribution, after_kid_contribution)

# Calculate fund returns for conservative portfolio
fund_returns_conservative = calculate_fund_returns(
    results_conservative,
    time_to_new_job,
    time_to_kid,
    starting_contribution,
    next_job_contribution,
    after_kid_contribution,
    investment_mix_2
)

# Print summary
print_fund_returns_summary(fund_returns_conservative, "Moderately Conservative")

"""## Plots"""

# Calculate median time series for each fund
max_months = 181 # 15 years * 12 months + 1 for month 0
years = np.arange(max_months) / 12

# Initialize dictionaries to hold time series data for each fund
fund_timeseries = {
    'SP500': [],
    'NASDAQ100': [],
    'TBILL_3M': [],
    'HYSA': [],
    'Emergency_fund': [],
    'Baseline': []
}

# Extract time series data for each fund from all simulations
for result_dict in results_aggressive['result_dict']: # Using aggressive results as an example
    if len(result_dict['Month_Index']) == max_months:
        for fund in fund_timeseries.keys():
            fund_timeseries[fund].append(result_dict[fund])

# Convert lists to numpy arrays for median calculation
for fund in fund_timeseries.keys():
    fund_timeseries[fund] = np.array(fund_timeseries[fund])

# Calculate median time series for each fund
median_fund_values = {}
for fund, data_array in fund_timeseries.items():
    if data_array.shape[0] > 0: # Ensure there is data for the fund
        median_fund_values[fund] = np.median(data_array, axis=0)

# Calculate the median total portfolio value (including emergency fund)
# Check if the keys exist before summing
median_total_portfolio = np.zeros(max_months)
all_funds = ['SP500', 'NASDAQ100', 'TBILL_3M', 'HYSA', 'Emergency_fund']
for fund in all_funds:
    if fund in median_fund_values:
        median_total_portfolio += median_fund_values[fund]


# Create the plot
fig, ax = plt.subplots(figsize=(14, 8))

colors = {
    'SP500': 'steelblue',
    'NASDAQ100': 'green',
    'TBILL_3M': 'orange',
    'HYSA': 'purple',
    'Emergency_fund': 'brown',
    'Baseline': 'red',
    'Total_Portfolio': 'darkblue' # Color for the total portfolio line
}

labels = {
    'SP500': 'S&P 500',
    'NASDAQ100': 'NASDAQ 100',
    'TBILL_3M': '3-Month T-Bills',
    'HYSA': 'HYSA (Investment Portion)',
    'Emergency_fund': 'Emergency Fund',
    'Baseline': 'Baseline (HYSA only)',
    'Total_Portfolio': 'Total Portfolio Value (Median)' # Label for the total portfolio line
}


for fund, median_values in median_fund_values.items():
    ax.plot(years[:len(median_values)], median_values, color=colors[fund], linewidth=2, label=labels[fund])

# Add the total portfolio line
ax.plot(years[:len(median_total_portfolio)], median_total_portfolio, color=colors['Total_Portfolio'], linewidth=3, linestyle='-', label=labels['Total_Portfolio'], zorder=100)


# Add vertical lines at 5 and 10 years
ax.axvline(5, color='gray', linestyle=':', linewidth=2, alpha=0.7, label='5 Years')
ax.axvline(10, color='gray', linestyle=':', linewidth=2, alpha=0.7, label='10 Years')

# Set appropriate axis limits
ax.set_xlim(0, 15)
# Dynamically set y-axis limits based on the data
all_median_values = np.concatenate(list(median_fund_values.values()) + [median_total_portfolio]) # Include total portfolio in limits
y_max = np.max(all_median_values) * 1.1
y_min = np.min(all_median_values) * 0.9
ax.set_ylim(y_min, y_max)


ax.set_xlabel('Years', fontsize=12)
ax.set_ylabel('Median Fund Value ($)', fontsize=12)
ax.set_title('Median Value of Each Fund and Total Portfolio Over Time (Moderately Aggressive Simulation)',
             fontsize=14, fontweight='bold')
ax.legend(fontsize=11, loc='upper left')
ax.grid(True, alpha=0.3)
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))

plt.tight_layout()
plt.show()

# Calculate median, 10th, 25th, and 75th percentiles for both simulations and baseline

max_months = 181 # 15 years * 12 months + 1 for month 0
years = np.arange(max_months) / 12

def calculate_percentiles_and_median(simulation_results):
    """Helper function to calculate percentiles and median time series."""
    all_timeseries = []
    for result_dict in simulation_results['result_dict']:
        if len(result_dict['Month_Index']) == max_months:
            total = [result_dict['SP500'][j] + result_dict['NASDAQ100'][j] +
                     result_dict['TBILL_3M'][j] + result_dict['HYSA'][j] +
                     result_dict['Emergency_fund'][j] for j in range(max_months)]
            all_timeseries.append(total)
    timeseries_array = np.array(all_timeseries)

    median = np.median(timeseries_array, axis=0)
    p10 = np.percentile(timeseries_array, 10, axis=0)
    p25 = np.percentile(timeseries_array, 25, axis=0)
    p75 = np.percentile(timeseries_array, 75, axis=0)

    return median, p10, p25, p75

# Calculate for Moderately Aggressive
median_aggressive, p10_aggressive, p25_aggressive, p75_aggressive = calculate_percentiles_and_median(results_aggressive)

# Calculate for Moderately Conservative
median_conservative, p10_conservative, p25_conservative, p75_conservative = calculate_percentiles_and_median(results_conservative)

# Baseline (assuming it's consistent across all results)
baseline_timeseries = np.array([results_aggressive['result_dict'][0]['Baseline'][j]
                                for j in range(max_months)])


# Create the plot
fig, ax = plt.subplots(figsize=(14, 8))

# Plot Baseline
ax.plot(years, baseline_timeseries, color='red', linewidth=3,
        label='Baseline (HYSA only)', linestyle='--')

# Plot Moderately Aggressive Percentiles and Median
ax.plot(years, median_aggressive, color='darkblue', linewidth=3, label='Moderately Aggressive (Median)')
ax.plot(years, p10_aggressive, color='blue', linewidth=1.5, linestyle=':', alpha=0.7, label='Moderately Aggressive (10th %ile)')
ax.plot(years, p25_aggressive, color='blue', linewidth=1.5, linestyle='--', alpha=0.7, label='Moderately Aggressive (25th %ile)')
ax.plot(years, p75_aggressive, color='blue', linewidth=1.5, linestyle='--', alpha=0.7, label='Moderately Aggressive (75th %ile)')


# Plot Moderately Conservative Percentiles and Median
ax.plot(years, median_conservative, color='darkgreen', linewidth=3, label='Moderately Conservative (Median)')
ax.plot(years, p10_conservative, color='green', linewidth=1.5, linestyle=':', alpha=0.7, label='Moderately Conservative (10th %ile)')
ax.plot(years, p25_conservative, color='green', linewidth=1.5, linestyle='--', alpha=0.7, label='Moderately Conservative (25th %ile)')
ax.plot(years, p75_conservative, color='green', linewidth=1.5, linestyle='--', alpha=0.7, label='Moderately Conservative (75th %ile)')


# Add vertical lines at 5 and 10 years
ax.axvline(5, color='gray', linestyle=':', linewidth=2, alpha=0.7, label='5 Years')
ax.axvline(10, color='gray', linestyle=':', linewidth=2, alpha=0.7, label='10 Years')

# Set appropriate axis limits
ax.set_xlim(0, 15)
# Dynamically set y-axis limits based on the data
all_values = np.concatenate([baseline_timeseries, median_aggressive, p10_aggressive, p25_aggressive, p75_aggressive,
                             median_conservative, p10_conservative, p25_conservative, p75_conservative])
y_max = np.max(all_values) * 1.1
y_min = np.min(all_values) * 0.9
ax.set_ylim(y_min, y_max)


ax.set_xlabel('Years', fontsize=12)
ax.set_ylabel('Portfolio Value ($)', fontsize=12)
ax.set_title('Portfolio Value Over Time - Aggressive vs. Conservative vs. Baseline',
             fontsize=14, fontweight='bold')
ax.legend(fontsize=10, loc='upper left')
ax.grid(True, alpha=0.3)
ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: f'${x/1000:.0f}K'))

plt.tight_layout()
plt.show()